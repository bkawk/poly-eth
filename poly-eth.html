<link rel="import" href="../polymer/polymer.html">
<script src="../web3/dist/web3.min.js" async></script>
<script src="../eth-util-browserified/eth-util.min.js" async></script>

<!--
`poly-eth`

@demo demo/index.html
-->

<dom-module id="poly-eth">
  <template>
    <style>
      :host {
        display: block;
      }
    </style>
  </template>

  <script>
    class MyElement extends Polymer.Element {
      static get is() { return 'poly-eth'; }
      static get properties() {
        return {
          web3: {
            type: Object
          },
        };
      }

    connectedCallback(){
      super.connectedCallback();
      // this.restoreAddress('dfs ddssd  qwer qwer qwer qwer qwer q fsd fsd ', 'S3df3s#df!defdf')
      // this.makeAddress('sDfsd907f@#sdf')
      // this.getPassphrase('sDfsd907f@#sdf')
      // changeVaultPassword(passphrase, oldVaultPassword, newVaultPassword)
      // this.changeVaultPassword('dfs ddssd  qwer qwer qwer qwer qwer q fsd fsd ', 'sDfsd907f@#sdf', 'NEWsDfsd907f@#sdf')
      // this._getEthBallance('0x1488e397bc44c56d801a6e96217554a0e310ecb5')
       this._ethFx(100, 'usd', 'X-ETH')
    }
    
    makeAddress(vaultPassword){
      Promise.all([this._checkLocalStorage('isNull'), this._strengthTest(vaultPassword), this._passphrase()])
      .then((data) => {
        return Promise.all([this._makeAddress(data[2]), this._encrypt(data[2], vaultPassword)])
      })
      .then((data) => {
        this._saveLocalStorage(data[0], data[1])
      })
      .catch((err) => {
        console.error(err)
      })
    }

    getPassphrase(vaultPassword){
      Promise.all([this._checkLocalStorage('notNull'), this._strengthTest(vaultPassword)])
      .then((data) => {
        return this._decrypt(vaultPassword)
      })
      .catch((err) => {
        console.error(err)
      })
    }

    restoreAddress(passphrase, vaultPassword){
      Promise.all([this._deleteLocalStorage(), this._strengthTest(vaultPassword)])
      .then((data) => {
        return Promise.all([this._makeAddress(passphrase), this._encrypt(passphrase, vaultPassword)])
      })
      .then((data) => {
        this._saveLocalStorage(data[0], data[1])
      })
      .catch((err) => {
        console.error(err)
      })
    }

    changeVaultPassword(passphrase, oldVaultPassword, newVaultPassword){
      Promise.all([this._strengthTest(oldVaultPassword), this._strengthTest(newVaultPassword), this._checkLocalStorage('notNull')])
      .then(() => {
        return this._decrypt(oldVaultPassword)
      })
      .then((vaultPassphrase) => {
        return this._compare(passphrase, vaultPassphrase)
      })
      .then(() => {
        return Promise.all([this._deleteLocalStorage(), this._makeAddress(passphrase), this._encrypt(passphrase, newVaultPassword)])
      })
      .then((data) => {
        this._saveLocalStorage(data[1], data[2])
      })
      .catch((err) => {
        console.error(err)
      })
    }


    transferEth(fromAddress, toAddress, ethAmount, metaData){

    }

    _getEthBallance(address){
      return new Promise((resolve, reject) => {
        this._gethConnect()
        this.web3.eth.getBalance(address, (error, balance) => {
          if(!error){
            resolve(balance.toString(10))
          } else {
            reject()
          }
        })
      })
    }

    _ethFx(amount, currencyCode, direction){
      return new Promise((resolve, reject) => {
        var xmlhttp = new XMLHttpRequest();
        xmlhttp.onreadystatechange = function() {
          if (xmlhttp.readyState == XMLHttpRequest.DONE ) {
            if (xmlhttp.status == 200) {
              var price = JSON.parse(xmlhttp.responseText).price;
              var fx
              switch (currencyCode) {
                case 'aud': fx = price.aud; break;
                case 'brl': fx = price.brl; break;
                case 'btc': fx = price.btc; break;
                case 'cad': fx = price.cad; break;
                case 'chf': fx = price.chf; break;
                case 'cny': fx = price.cny; break;
                case 'eur': fx = price.eur; break;
                case 'gbp': fx = price.gbp; break;
                case 'hkd': fx = price.hkd; break;
                case 'idr': fx = price.idr; break;
                case 'inr': fx = price.inr; break;
                case 'jpy': fx = price.jpy; break;
                case 'krw': fx = price.krw; break;
                case 'mxn': fx = price.mxn; break;
                case 'rub': fx = price.rub; break;
                case 'usd': fx = price.usd;
              }
              if(direction == 'X-ETH'){
                resolve(amount / fx)
              } else {
                resolve(amount * fx)
              }
            }
            else if (xmlhttp.status == 400) {
              reject('There was an error 400');
            }
            else {
              reject('something else other than 200 was returned');
            }
          }
        };
      xmlhttp.open("GET", "https://coinmarketcap-nexuist.rhcloud.com/api/eth", true);
      xmlhttp.send();
      })
    }
    _createEthTransation(){
      return new Promise((resolve, reject) => {
      
      })
    }
    _signEthTransaction(){
      return new Promise((resolve, reject) => {
      
      })
    }
    _sendEthTransaction(){
      return new Promise((resolve, reject) => {
      
      })
    }
    _compare(thisItem, thatItem){
      return new Promise((resolve, reject) => {
        if(thisItem === thatItem){
          resolve(true)
        } else {
          reject(false)
        }
      })
    }
    _gethConnect(){
      return new Promise((resolve, reject) => {
        if (typeof web3 !== 'undefined') {
          this.web3 = new Web3(web3.currentProvider);
        } else {
          this.web3 = new Web3(new Web3.providers.HttpProvider("http://eth.bkawk.com"));
        }
      })
    }
    _makeAddress(passphrase){
      return new Promise((resolve, reject) => {
        resolve(`0x${eth.util.privateToAddress(eth.util.sha3(passphrase)).toString('hex')}`)
      })
    }
    _passphrase(){
      return new Promise((resolve, reject) => {
        resolve(eth.bip39.generateMnemonic())
      })
    }
    _strengthTest(password){
      return new Promise((resolve, reject) => {
        if(!eth.strength.test(password).strong){
          reject(eth.strength.test(password).errors)
        } else {
          resolve(true)
        }
      })
    }
    _checkLocalStorage(val){
      return new Promise((resolve, reject) => {
        if(val == 'isNull'){
          if(localStorage.getItem("vault")){
            reject('vault')
          } else {
            resolve(true)
          }
        }
        if(val == 'notNull'){
          if(!localStorage.getItem("vault")){
            reject('vault')
          } else {
            resolve(true)
          }
        }
      })
    }
    _deleteLocalStorage(){
      return new Promise((resolve, reject) => {
        if (typeof(Storage) !== "undefined") {
          localStorage.removeItem('vault');
          resolve(true)
        } else {
          reject('vault')
        }
      })
    }
    _saveLocalStorage(address, passphrase){
      return new Promise((resolve, reject) => {
        if (typeof(Storage) !== "undefined") {
          localStorage.setItem("vault", JSON.stringify({ "ethAddress": address, "passphrase": passphrase}));
          resolve(true)
        } else {
          reject('vault')
        }
      })
    }
    _encrypt(passphrase, password){
      return new Promise((resolve, reject) => {
        var password = new Uint8Array(eth.util.sha3(password));
        var textBytes = eth.aes.utils.utf8.toBytes(passphrase);
        var aesCtr = new eth.aes.ModeOfOperation.ctr(password, new eth.aes.Counter(5));
        var encryptedBytes = aesCtr.encrypt(textBytes);
        var encryptedHex = eth.aes.utils.hex.fromBytes(encryptedBytes);
        resolve(encryptedHex);
      })
    }
    _decrypt(password){
      return new Promise((resolve, reject) => {
        var password = new Uint8Array(eth.util.sha3(password));
        var encryptedHex = JSON.parse(localStorage.getItem("vault")).passphrase;
        var encryptedBytes = eth.aes.utils.hex.toBytes(encryptedHex);
        var aesCtr = new eth.aes.ModeOfOperation.ctr(password, new eth.aes.Counter(5));
        var decryptedBytes = aesCtr.decrypt(encryptedBytes);
        var decryptedText = eth.aes.utils.utf8.fromBytes(decryptedBytes);
        resolve(decryptedText);
      })
    }
    _gtEthBalance(account){
      this.web3.eth.getBalance(account, 'latest', (err, result) => {
        if (err) { 
          console.error("Error while retrieving the balance for address " + err);
        } else {
          console.debug("Balance = "+ Number(this.web3.fromWei(result, "ether")) ); 
        }            
      }); 
    }

    } window.customElements.define(MyElement.is, MyElement);
  </script>
</dom-module>
